【C语言】动态内存管理
原创fighting QAQ 最后发布于2020-03-08 13:11:47 阅读数 52  收藏
编辑 展开
动态内存管理
为什么存在动态内存分配
我们所掌握的内存开辟方式主要分为类型的定义和数组开辟
eg：int val = 10；//在栈上开辟四个字节
char array[10] = {0};//在栈上用数组开辟了十个字节的连续空间
上述开辟空间的方法其开辟大小是固定的，数组在声明的时候，必须指定数组长度。但对空间的需求，是在程序运行时才能知道，无法准确定义空间大小，可能会存在空间分配过小，内存不足或者空间过大，内存浪费的问题，所以延伸出动态内存分配。

动态内存分配的主要函数及其用法
内存分配的主要函数有：malloc,realloc,calloc,c++中则使用new
存分配的主要函数有：free,c++中则使用delete
malloc和free
malloc的函数接口：void* malloc（size_t size);
这个函数向内存申请一块连续可用的空间，并返回指向这块空间的指针。
如果开辟成功，则返回一个指向开辟好空间的指针。
如果开辟失败，则返回一个NULL指针，因此malloc的返回值一定要做检查。
返回值的类型是 void* ，所以malloc函数并不知道开辟空间的类型，具体在使用的时候使用者自己来决定。
free函数用来释放动态开辟的内存。
如果参数 ptr 指向的空间不是动态开辟的，那free函数的行为是未定义的。
如果参数 ptr 是NULL指针，则函数什么事都不做。
eg:
上面这段我演示了malloc申请和free释放的过程，我们应该注意代码里的一些细节：

malloc申请的函数其返回值的类型为void*,我们需要将其强转成我们指针所需要的类型，且malloc申请空间大小是按字节来计算的，并不是字符的个数

申请空间完成后，应该对指针所指向的空间进行判空，看是否申请成功

空间使用完毕必须进行释放，防止实现内存泄漏，且指针需再次置空，以免出现野指针的问题

calloc
C语言还提供了一个函数叫 calloc ， calloc 函数也用来动态内存分配。
calloc函数接口：void* calloc（size_t num，size_t size）;
函数的功能是为 num 个大小为 size 的元素开辟一块空间，并且把空间的每个字节初始化为0。
calloc和malloc的区别：
与函数 malloc 的区别只在于 calloc 会在返回地址之前把申请的空间的每个字节初始化为全0。 举个例子：
上述是其申请空间的用法，后面步骤与malloc用法相同，不在详细描述。所以如果我们对申请内存空间内容要求初始化，那么可以使用calloc函数来完成任务。
realloc
realloc函数的出现让动态内存管理更加灵活。
有时会我们发现过去申请的空间太小了，有时候我们又会觉得申请的空间过大了，那为了合理的时候内存，
我们一定会对内存的大小做灵活的调整。那 realloc 函数就可以做到对动态开辟内存大小的调整。
realloc函数接口：void* realloc(void* ptr，size_t size);
ptr 是要调整的内存地址
size 调整之后新大小
返回值为调整之后的内存起始位置。
这个函数调整原内存空间大小的基础上，还会将原来内存中的数据移动到 新 的空间。
realloc在调整内存空间的是存在两种情况：
情况1：原有空间之后有足够大的空间
情况2：原有空间之后没有足够大的空间

常见realloc多是适用于指针所指向的空间不足时扩容
举个栗子：

若不使用realloc,要实现函数增容则要进行以下几步：1.开辟新空间，2.将就空间元素拷贝到新空间3.释放就空间
使用realloc则更加方便，代码更简单。
以上便是常用动态内存开辟的函数及其使用方法，malloc模块中详细叙述了动态内存分配的流程及方法，还有其中的陷阱。
————————————————
版权声明：本文为CSDN博主「fighting QAQ」的原创文章，遵循 CC 4.0 BY-SA 版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_43676757/article/details/104729614
