C语言：浮点型在内存中的存储

羊驼儿 2020-02-29 23:31:04  18  收藏
展开
浮点数存储

浮点数家族
float
double
long double

注：浮点数的范围：在float.h中定义

#include <stdio.h>
#include <Windows.h>

int main()
{
	int n = 9;
	float *pFloat = (float *)&n;//强制转换
	printf("int：%d\n", n);
	printf("float的值为：%f\n", *pFloat);

	*pFloat = 9.0;
	printf("int：%d\n", n);
	printf("float：%f\n", *pFloat);
	system("pause");
	return 0;
	
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17

从输出结果可以看出，浮点数和整数的解读结果有很大的区别，在了解这种区别前，我们先来了解浮点数在计算机内部的表示方法：
根据国际标准IEEE754，任意一个二进制浮点数V可以表示成下面的形式：

（-1）^ S * M * 2 ^ E
（-1）^ S表示符号位，当S=0，V为正数，当S=1，V为负数
M表示有效数字，大于等于1，小于2
2^E表示数位

例如：十进制的5.0，写成二进制101.0，相当于1.01×2^2
按照标准形式写成：S=0，M=1.01，E=2
十进制的 -5.0，写成二进制 -101.0，相当于 -1.01×2^2
按照标准形式写成：S=1，M=1.01，E=2

总结:任何一个浮点数一定可以用标准的科学计数法表示
而任何一标准的科学计数法也可转换为浮点数
存储浮点数的本质是在存取（S、M、E）

对于有效数字M特别规定，因为1≤M≤2，即M可以写为1.×××××××的形式，其中×××××××表示小数部分
根据规定，在计算机内部保存M时，默认这个数的第一位是1，因此可以被舍去，只保存×××××××部分，例如：
保存1.01的时候，只保存01，当读取时将第一位的1加上去
这样可以节省一位有效数字

关于指数E的具体说明
E是一个无符号整数，则它的取值范围为0~255；如果E为11位，它的取值范围是0 ~2047，但在科学计数法的过程中E是可以出现负数的，所以IEEE 754规定，存入内存时E的真实值必须再加上一个中间数，对于单精度浮点数，中间数是127，对于双精度浮点数，中间数是1023，例如2^10的E是10，保存位32位浮点数时，保存为10+127=137，即1000 1001

E全为0或不全为0
指数E的计算值减去123(或1023)，得到真实值，再将有效数字M前加上第一位的1，例如：
0.5的二进制形式是0.1，由于规定正数部分必须为1，即将小数点右移一位，则为1.0*2^(-1),其阶码为-1+127=126，表示为0111 1110，而尾数1.0去掉整数部分为0，补齐0到23位，则其二进制表示形式为
0 01111110 00000000000000000000000

E全为0
此时浮点数的指数E等于1-127，有效数字M不再加上第一位的1，而是还原为0.×××××××的小数，这样可以表示正负0以及很接近0的很小的数字

E全为1
有效数字E全为1，表示正负无穷大（最大或者最小值）正负取决于符号位



将数字还原为二进制序列发现正是刚刚保存的序列
因此运行结果9.0 int在读取时会读成 1091567616
延伸总结：


不能将float直接存储在别的类型中，在第二种情况中，没有出现报错的原因是，计算机默认强制转换了
————————————————
版权声明：本文为CSDN博主「羊驼儿」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_44851228/article/details/103322205
