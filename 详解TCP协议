# 详解TCP协议

前言：
上篇博客主要讲述了udp协议，先回顾一下udp编程流程和注意事项
udp编程：
服务端：
1.创建套接字
2.为套接字绑定地址信息
3.接收数据请求
4.处理后，发送数据
5.关闭套接字
客户端
1.创建套接字
2.为套接字绑定地址信息
3.发送数据请求
4.服务端处理后，响应请求
5.关闭套接字
【注意事项】
1。udp编程，首先应启动服务端，因为用户数据报协议的特点就是无连接不可靠，如果先启动客户端，可能会造成传输时数据丢失。
2.客户端不推荐主动绑定地址，而是在发送数据时由操作系统选择合适的地址信息进行绑定（尽最大可能避免出现端口冲突的概率）
服务端必须主动绑定，因为需要保证地址永远不变才能被客户端找到

# tcp编程
传输特性：**面向连接**，可靠传输，面向字节流
本篇博客主要详细叙述面向连接的相关内容
这里面向连接使用到很经典且重要且常问的**三次握手，四次挥手**过程，后面细讲。

## TCP协议的传输特点（详解）

TCP协议是一个面连接的传输层协议，提供高可靠性字节流传输服务，主要用与一次传输要交换大量报文情形。
为了维护传输的的可靠性，TCP增加了许多开销，如：确认、流量控制、计时器以及连接管理等。

**端到端通信**：TCP提供给应用面向连接的接口。TCP连接时端到端的，客户应用程序在一端，服务器在另一端。
**建立可靠连接**:TCP要求客户应用程序在与服务器交换数据前，先连接服务器，保证连接可靠建立，建立连接测试了网络的连通性。如果有故障发生，阻碍了分组到达远端系统，或者服务器不接受连接，那么企图连接就会失败，客户就会得到通知。
可靠交付：一旦建立连接，TCP保证数据将按发送时的顺序交付，没有丢失，也没有重复，如果因为故障而不能建立可靠交付，发送方会得到通知。
具有流控的传输：TCP控制数据传输的效率，防止发送数据的速率快与接收方的接收速率，因此TCP可以用于从快速计算机向慢速计算机传输数据。
**双工传输**：在任何时候，单个TCP连接都允许同时双向传送数据，而且不会相互影响，因此客户可以向服务器发送请求，而服务器可以通过同一个连接发送应答。
**流模式**：TCP从发送方向接收方发送没有报文边界的字节流。

TCP的首部
TCP数据被封装在一个IP数据包中！！！如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200406130113945.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc2NzU3,size_16,color_FFFFFF,t_70)
下图则显示了TCP首部的数据格式，如果不记选项字段，他们通常是20个字节。
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020040613012547.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc2NzU3,size_16,color_FFFFFF,t_70)
TCP首部个字段的含义如下(大致掌握)
 1.**源、目的端口号**：每个TCP报文段都包含源端口号和目的端口号，用于寻找发送端和接收端的应用进程。
 2.序号和确认序号：序号用来表示从TCP发送端向TCP接收端发送的数据字节流，它表示在这个报文字段中的第一个数据字节。如果将字节流看作在两个应用程序间的单向流动，则TCP用序号对每个字节流进行计数。序号是32位的无符号数。确认序号是发送确认的一端所期望收到的下一个序号。因此，确认序号应当是上次已成功收到数据字节序号加1。只有ACK标志为1时，确认序号字段才有效。
 3.首部长度：首部长度给出首部中32位字的数目。需要这个只是因为选项字段的长度是可变的。这个字段占4位，因此TCP最多有60字节的首部。如果没有选项字段，正常的长度时20字节。
 4.**标志位**：在TCP首部中有6个标志位。 它们中的多个可同时被设置为1，其含义分别如下：
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200406130342491.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc2NzU3,size_16,color_FFFFFF,t_70)
 5.窗口大小：TCP的流量控制由连接的每一端通过声明的窗口大小来提供。窗口大小为字节数起始于确认序号字段指明的值，这个值是接收端正期望接受的字节编号。窗口大小是一个16位字段，因而窗口大小最大为65535字节。
 6.检验和：检验和覆盖了整个的TCP报文段，包含TCP首部、TCP伪首部和TCP数据。这是一个强制性的字段，一定是由发送端计算和存储的，并由接收端进行校验。
 7.紧急指针：只有当URG标志位置1时，紧急指针才有效。紧急指针是一个正的偏移量，与序号字段中的值相加表示紧急数据最后一个字节的序号。这是发送端向另一端发送紧急数据的一种方式。
 8.选项：TCP首部的选项部分是TCP为了适应复杂网络环境和更好地服务应用层设计的，选项部分最长可达40字节。最常见的选项字段是最大报文段大小(MaximumSegment ,MSS)。每个连接方通常都在通信的第一个报文段(为建立连接而设置的SYN标志位的那个段)中指明这个选项。它指明本端所能接受的最大长度的报文段。
 9.数据：TCP报文段中的数据部分是可选的。例如在连接建立和连接终止时，双方交换的报文段仅有TCP首部。一方即使没有数据要发送，也使用没有任何数据的首部来确认收到的数据。在处理超时的许多情况中，也会发送不带任何数据的报文段。

## 客户端和服务端tcp协议通信

## 通信整体流程

 **服务器流程:**
调用socket, 创建文件描述符;
调用bind, 将当前的文件描述符和ip port(ip地址和端口)绑定在一起; 如果这个端口已经被其他进程占用了, 就会bind失败;
调用listen, 声明当前这个文件描述符作为一个服务器的文件描述符, 为后面的accept做好准备;
调用accecpt, 并**阻塞**, 等 客户端连接过来;
调用send/recv  收发数据
调用close  关闭套接字
**客户端流程:**
调用socket, 创建文件描述符;
调用[bind],同理不主动绑定地址信息，由操作系统分配
调用connect,建立连接成功
调用send/recv  收发数据
调用close  关闭套接字

## 通信流程
**客户端与服务端建立连接流程，“三次握手”（重点必考）**
|信号|作用|
URG	紧急指针是否有效
ACK	确认号是否有效
PSH	提示接收端应用程序立刻从TCP缓冲区把数据读走
RST	对方要求重新建立连接; 我们把携带RST标识的称为复位报文
SYN	请求建立连接; 我们把携带SYN标识的称为同步报文段
FIN	通知对方, 本端要关闭了, 我们称携带FIN标识的为结束报文段


详细版：
1.客户端发送一个SYN报文段指明客户打算连接服务器端口号，以及初始序号(Initial SequenceNumber,ISN),**SYN请求连接**发送后，客户进入**SYN_SENT等待请求连接状态。**
 2.服务器启动后首先进入**LISTEN监听**状态，当它接收到客户端发来的SYN请求后，进入**SYN_RCV接收请求状态**，发回包含服务器的初始序号的SYN报文段作为应答，同时将确认需要设置为客户的初始序号加1，对客户的SYN报文段进行确认。一个SYN将占用一个序号。
 3.客户接受到服务器的确认报文后进入ESTABLISHED(建立)状态，表明本方连接已经成功建立，客户将确认序号设置为服务器的ISN加1，的对服务器的SYN报文段进行确认，当服务器接收到该确认报文后，也进入ESTABLISHED（建立）状态
 **建立连接的过程(简化版):**
调用socket, 创建文件描述符;
调用connect, 向服务器发起连接请求;
connect会发 SYN段并阻塞等待服务器应答; (第一次)
服务器收到客户端的SYN, 会应答一个SYN-ACK段表示"同意建立连接"; (第二次)
客户端收到SYN-ACK后会从connect()返回, 同时应答一个ACK段; (第三次)
这个建立连接的过程, 通常称为 **三次握手;**
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200406131519681.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc2NzU3,size_16,color_FFFFFF,t_70)
**数据传输的过程**
建立连接后,TCP协议提供全双工的通信服务; 所谓全双工的意思是, 在同一条连接中, 同一时刻, 通信双方
可以同时写数据; 相对的概念叫做半双工, 同一条连接在同一时刻, 只能由一方来写数据;
服务器从accept()返回后立刻调 用read(), 读socket就像读管道一样, 如果没有数据到达就阻塞等待;
这时客户端调用write()发送请求给服务器, 服务器收到后从read()返回,对客户端的请求进行处理, 在此期
间客户端调用read()阻塞等待服务器的应答;
服务器调用write()将处理结果发回给客户端, 再次调用read()阻塞等待下一条请求;
客户端收到后从read()返回, 发送下一条请求,如此循环下去;
**断开连接的过程（四次挥手）（重点必考）**:
如果客户端没有更多的请求了, 就调用close()关闭连接, 客户端会向服务器发送FIN段(第一次);
此时服务器收到FIN后, 会回应一个ACK, 同时read会返回0 (第二次);
read返回之后, 服务器就知道客户端关闭了连接, 也调用close关闭连接, 这个时候服务器会向客户端发送一个FIN; (第三次)
客户端收到FIN, 再返回一个ACK给服务器; (第四次)
这个断开连接的过程, 通常称为 “四次挥手”
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200406132122358.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNjc2NzU3,size_16,color_FFFFFF,t_70)
为什么需要TIME WAIT状态呢?
1.TIME_WAIT状态延长了TCP对当前连接的维护信息，对于正确处理连接的正常关闭过程中**确认报文丢失是很有必要的。**
2.TIME_WAIT状态**确保了旧连接的报文段在网络上消失之前不会被重用**，从而防止扰乱新连接。
参考博客：
https://blog.csdn.net/L19002S/article/details/103667549
