C++多态（一）概念及知识点详解

fighting QAQ 2020-07-11 11:46:41  5  收藏
分类专栏： C++ 文章标签： 多态抽象类接口类
编辑 版权
C++多态（一）概念及知识点
【本篇内容】
C++多态（一）概念及知识点
1.多态的概念
2. 多态的定义及实现
2.1多态的构成条件
2.2虚函数
2.3虚函数重写
2.4易混淆知识点
2.4.1多态调用和普通函数调用（易混淆）
2.4.2子类虚函数可省略virtual
2.4.3虚函数重写的例外1：协变
2.4.4虚函数重写的例外2：析构函数重写
3.抽象类
3.1概念
3.2接口继承和实现继承（了解）
1.多态的概念
多态的概念：通俗来说，就是多种形态，具体点就是去完成某个行为，当不同的对象去完成时会产生出不同的状态。

举个栗子：比如买票这个行为，当普通人买票时，是全价买票；学生买票时，是半价买票；军人买票时是优先买票。

2. 多态的定义及实现
2.1多态的构成条件
要构成多态还有两个条件：
1. 必须通过基类的指针或者引用调用虚函数
2. 被调用的函数必须是虚函数，且派生类必须对基类的虚函数进行重写

2.2虚函数
虚函数：即被virtual修饰的类成员函数称为虚函数。（注意必须是类成员函数被virtual修饰才行）

2.3虚函数重写
虚函数的重写(覆盖)：派生类中有一个跟基类完全相同的虚函数(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，称子类的虚函数重写了基类的虚函数。
举个栗子：

#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
class person
{
public:
	virtual void BuyTicket()
	{
		  cout << "学生-半价" << endl;
	}
};
class student : public person
{
public:
	virtual void BuyTicket()
	{
		  cout << "学生-全价" << endl;
	}
};
void func(person& p)
{
	p.BuyTicket();
}
int main()
{
	person p;
	student s;
	func(p);
	func(s);
	system("pause");
	return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
多态条件：
1.派生类完成对于基类的虚函数重写

2.必须通过基类的指针或引用调用虚函数

构成多态：


2.4易混淆知识点
2.4.1多态调用和普通函数调用（易混淆）
满足多态:跟指向对象有关，指向哪个对象就调用他的虚函数
不满足多态：跟调用对象的类型有关，类型是谁的调用的就是谁的虚函数
举个栗子：
满足多态：


不满足多态（我们破坏虚函数重写的条件）：




2.4.2子类虚函数可省略virtual
在重写基类虚函数时，派生类的虚函数在不加virtual关键字时，也可以构成重写。原因是派生类继承基类属性之后依然保持虚函数属性。,但是该种写法不是很规范，不建议这样使用
判断题常考：
这是虚函数重写吗？

答案：是的，好多人被重写的定义带坑里了(即派生类虚函数与基类虚函数的返回值类型、函数名字、参数列表完全相同)，要记住这个特殊的

2.4.3虚函数重写的例外1：协变
派生类重写基类虚函数时，与基类虚函数返回值类型不同。即基类虚函数返回基类对象的指针或者引用，派生类虚函数返回派生类对象的指针或者引用时，称为协变。（了解就行，判断题挖坑：虚函数重写返回值类型必须相同吗？错，协变）
举个栗子：
函数名不同，依然可以实现多态



2.4.4虚函数重写的例外2：析构函数重写
如果基类的析构函数为虚函数，此时派生类析构函数只要定义，无论是否加virtual关键字，都与基类的析构函数构成重写，虽然基类与派生类析构函数名字不同。虽然函数名不相同，看起来违背了重写的规则，其实不然，这里可以理解为编译器对析构函数的名称做了特殊处理，编译后析构函数的名称统一处理成destructor。
砍代码：这个是一个经典代码

class Person {
public:
	 virtual ~Person() { cout << "~Person()" << endl; }
};

class Student : public Person {
public:
	virtual ~Student() { cout << "~Student()" << endl; }
};

int main()
{
	Person* p1 = new Person;
	Person* p2 = new Student;
	delete p1;
	delete p2;
	system("pause");
	return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
先破坏虚函数重写

这个代码不构成多态会直接崩掉，为什么

看是否构成多态


3.抽象类
3.1概念
在虚函数的后面写上 =0 ，则这个函数为纯虚函数。包含纯虚函数的类叫做抽象类（也叫接口类），抽象类不能实例化出对象。派生类继承后也不能实例化出对象只有重写纯虚函数，派生类才能实例化出对象。纯虚函数规范了派生类必须重写，另外纯虚函数更体现出了接口继承。
举例：

class Car
{
public:
 virtual void Drive() = 0;
};
class Benz :public Car
{
public:
 virtual void Drive()
 {
 cout << "Benz-舒适" << endl;
 }
};
class BMW :public Car
{
public:
 virtual void Drive()
 {
 cout << "BMW-操控" << endl;
 }
};
void Test()
{
 Car* pBenz = new Benz;
 pBenz->Drive();

 Car* pBMW = new BMW;
 pBMW->Drive();
}

29
3.2接口继承和实现继承（了解）
普通函数的继承是一种实现继承，派生类继承了基类函数，可以使用函数，继承的是函数的实现。虚函数的继承是一种接口继承，派生类继承的是基类虚函数的接口，目的是为了重写，达成多态，继承的是接口。所以如果不实现多态，不要把函数定义成虚函数
————————————————
版权声明：本文为CSDN博主「fighting QAQ」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_43676757/article/details/107282535
