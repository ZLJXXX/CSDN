C++继承（二）：菱形继承，常见面试题

fighting QAQ 2020-07-09 13:22:25  2  收藏
分类专栏： C++ 文章标签： c++编程语言
编辑 版权
C++继承（二）：菱形继承，常见面试题
本章内容
C++继承（二）：菱形继承，常见面试题
1.菱形继承的概念
2.详解
2.1菱形继承的问题
2.1.1数据二义性：
2.2.2数据冗余
2.2虚拟继承解决数据冗余和二义性
2.2.1用法
2.2.2虚拟继承的解决原理
3.继承的总结
4.常见面试题
1.菱形继承的概念
单继承：一个子类只有一个直接父类时称这个继承关系为单继承

多继承：一个子类有两个或以上直接父类时称这个继承关系为多继承

菱形继承：菱形继承是多继承的一种特殊情况。

菱形继承的问题：从下面的对象成员模型构造，可以看出菱形继承有数据冗余和二义性的问题。 在Assistant的对象中Person成员会有两份。


2.详解
2.1菱形继承的问题
2.1.1数据二义性：
#define _CRT_SECURE_NO_WARNINGS
#include<iostream>
using namespace std;
class Person
{
public:
	string _name; // 姓名
};
class Student : public Person
{
protected:
	int _num; //学号
};
class Teacher : public Person
{
protected:
	int _id; // 职工编号
};
class Assistant : public Student, public Teacher
{
protected:
	string _majorCourse; // 主修课程
};
void Test()
{
	// 这样会有二义性无法明确知道访问的是哪一个
	Assistant a;
	a._name = "peter";
}
int main()
{
	Test();
	system("pause");
	return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35

上面的代码就存在数据二义性的问题，Assistant 继承了Student和Teacher的类方法，但是Student和Teacher类都继承了Person类，那么Assistant类中的_name变量到底是继承那个类中的成员变量则不能知晓。

**解决：**显示调用需要访问的父类成员来解决二义性



2.2.2数据冗余
从上面代码也可以看出Assistant类继承了两个父类的_name变量，所以存在数据冗余，但是由于是字符串所以不好通过内存观察，我们来看下这个例子：

class A
{
public:
	int _a;
};
// class B : public A
class B :  public A
{
public:
	int _b;
};
// class C : public A
class C :  public A
{
public:
	int _c;
};
class D : public B, public C
{
public:
	int _d;
};
int main()
{
	D d;
	d.B::_a = 1;
	d.C::_a = 2;
	d._b = 3;
	d._c = 4;
	d._d = 5;
	return 0;
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
通过调试我们可以看到数据冗余，D类中存在两个_a变量这显然是不合理的

我们看一下D类的大小：

正常情况下应该是16个字节，为甚么会多一个呢？

通过观察我们可以看到A类中的_a变量被继承了两次。

2.2虚拟继承解决数据冗余和二义性
2.2.1用法
虚拟继承就是通过在继承方式前面加上virtual关键字进行

效果：



2.2.2虚拟继承的解决原理
首先我们先看一下D类的类存大小

为什么解决了数据冗余，D类的大小反而变大了？而不是16字节，我们查看一下内存

我们可以看到这里多出来了两块这是什么呢？其实它就是虚基表指针所以其D类的大小为24字节，**虚基表指针是用来让B类和C类来找到A类的。虚基表指针顾名思义是指向虚基表的，那么虚基表里放的是什么？作用是什么？**我们继续查看我们的内存

我们可以看到我们虚基表中存放这一些数字，12和20又是什么呢？ 其实虚基表中存放的是偏移量。偏移量的作用就是找到A类对象。

的Person关系（第一份代码）菱形虚拟继承的原理解释：


3.继承的总结
很多人说C++语法复杂，其实多继承就是一个体现。有了多继承，就存在菱形继承，有了菱形继承就有菱形虚拟继承，底层实现就很复杂。所以一般不建议设计出多继承，一定不要设计出菱形继承。否则在复杂度及性能上都有问题。
多继承可以认为是C++的缺陷之一，很多后来的OO语言都没有多继承，如Java。
4.常见面试题
什么是菱形继承？菱形继承的问题是什么？
答：上面详细说了

什么是菱形虚拟继承？如何解决数据冗余和二义性的？解决原理吗？
答：上面详细说了

继承和组合的区别？什么时候用继承？什么时候用组合？
答：
官话：
1.public继承是一种is-a的关系。也就是说每个派生类对象都是一个基类对象。
2.组合是一种has-a的关系。假设B组合了A，每个B对象中都有一个A对象。
3.优先使用对象组合，而不是类继承 。
4.继承允许你根据基类的实现来定义派生类的实现。这种通过生成派生类的复用通常被称为白箱复用(white-box reuse)。术语“白箱”是相对可视性而言：在继承方式中，基类的内部细节对子类可见 。继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高。
5.对象组合是类继承之外的另一种复用选择。新的更复杂的功能可以通过组装或组合对象来获得。对象组合要求被组合的对象具有良好定义的接口。这种复用风格被称为黑箱复用(black-box reuse)，因为对象的内部细节是不可见的。对象只以“黑箱”的形式出现。 组合类之间没有很强的依赖关系，
耦合度低。优先使用对象组合有助于你保持每个类被封装。
6.实际尽量多去用组合。组合的耦合度低，代码维护性好。不过继承也有用武之地的，有些关系就适合继承那就用继承，另外要实现多态，也必须要继承。类之间的关系可以用继承，可以用组合，就用组合。
我的理解：

is-a：宝马是车
has-a:车有轮子（大概理解就行）
相同点：继承和组合都是类复用的一种手段。
“不同”：
组合：
常规情况下更加常用，适用于has-a关系，是一种黑箱复用手段，不破坏类封装的特性， 组合类之间没有很强的依赖关系，耦合度低，代码易于维护。优先使用对象组合有助于你保持每个类被封装。
继承：
适用于is-a的关系，是一种白箱复用手段，继承一定程度破坏了基类的封装，基类的改变，对派生类有很大的影响。派生类和基类间的依赖关系很强，耦合度高。但也并非不好，实现多态必须要使用到继承，类之间的关系可以多用组合。
————————————————
版权声明：本文为CSDN博主「fighting QAQ」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_43676757/article/details/107221833
