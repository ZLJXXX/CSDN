大小端（数据在内存中的存储）

fighting QAQ 2021-02-24 14:52:06  收藏
分类专栏： C语言 文章标签： 补码 操作系统
编辑 版权
数据在内存中的存储
本篇目录
数据在内存中的存储
1 整形在内存中的存储：原码、反码、补码
1.1 原码、反码、补码
2 大小端
1 整形在内存中的存储：原码、反码、补码
1.1 原码、反码、补码
计算机中的符号数有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。

原码 直接将二进制按照正负数的形式翻译成二进制就可以。
反码 将原码的符号位不变，其他位依次按位取反就可以得到了。
补码反码+1就得到补码。 正数的原、反、补码都相同。

考点：计算机为什么的是数据的补码
1.可以将符号位和数值域统一处理；
2.加法和减法也可以统一处理（CPU只有加法器）；
3.补码与原码相互转换，其运算过程是相同的，不需要额外的硬件电路。

2 大小端
大端：是指数据的低位保存在内存的高地址中；
小端：是指数据的低位保存在内存的低地址中；
假如32位宽（uint32_t）的数据0x12345678，从地址0x00B7FE44开始存放:

地址	大端存储	小端存储
0x00B7FE44	0x12	0x78
0x00B7FE45	0x34	0x56
0x00B7FE46	…	…
再结合一张图进行理解：
在这里插入图片描述
测试代码：

#include<iostream>
#include<vector>
using namespace std;
int main(){
	short int x;
	char x0, x1;
	x = 0x12345678;
	x0 = ((char*)&x)[0]; //低地址单元
	x1 = ((char*)&x)[1]; //高地址单元
	system("pause");
	return 0;
}
若x0=0x11,则是大端; 若x0=0x22,则是小端
从上面的程序还可以看出，数据寻址时，用的是低位字节的地址。
1
2
3
4
5
6
7
8
9
10
11
12
13
14
在这里插入图片描述
作用：

小端模式：强制转换数据不需要调整字节内容，1、2、4字节的存储方式一样。

大端模式：符号位的判定固定为第一个字节，容易判断正负。

总结：大端小端没有谁优谁劣，各自优势便是对方劣势。

常见字节序

常见的操作系统是小端，通讯协议是大端。

1.常见CPU的字节序

大端模式：PowerPC、IBM、Sun

小端模式：x86、DEC
