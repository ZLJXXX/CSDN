数据结构排序算法 堆排

空洞的眼 眸阁 2019-07-30 14:39:48  37  收藏
展开
堆排

堆排序(Heapsort)是指利用堆积树（堆）这种数据结构所设计的一种排序算法，它是选择排序的一种。它是 通过堆来进行选择数据。需要注意的是排升序要建大堆，排降序建小堆

堆排序首先在于建堆，建大堆还是建小堆取决于排序是升序还是降序。堆在物理意义上是一个数组，逻辑意义上是一个完全二叉树。
初始化堆后，然后从堆尾第一个非叶子节点调整堆，(调整大顶堆)

	for (int i = (n - 2) / 2; i >= 0; i--)//从堆底第一个非孩子节点调整堆
	{
		AdjustDwon(a, n, i);
	}
1
2
3
4


void AdjustDwon(int* a, int n, int parint)//堆的调整
{
	int child = parint * 2 + 1;//默认定义左孩子

	while (child < n)
	{
		if (child + 1 < n && a[child + 1] > a[child])//如果右孩子大于左孩子的值，child+1
		{
			child++;
		}
		if (a[child] > a[parint])//在比较两个孩子中大的与父亲节点
		{
			Swap(&a[parint], &a[child]);
			parint = child;
			child = parint * 2 + 1;
		}
		else
		{
			break;
		}	
	}
	
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
排序的思路，在建好大堆后，每次交换堆顶与堆尾的数，数组个数减一；然后继续调整堆，将次大的调整到堆顶，继续交换、调整。



void HeapSort(int *a, int n)//堆排序
{
	//建堆
	int end = n - 1;

	for (int i = (n - 2) / 2; i >= 0; i--)//从堆底第一个非孩子节点调整堆
	{
		AdjustDwon(a, n, i);
	}
	while (end > 0)//判断条件时，每次数组个数减一，同时每次调整的个数也在变化
	{
		Swap(&a[0], &a[end]);
		//end--;
		AdjustDwon(a, end, 0);//注意end的使用
		end--;
	}
}
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
堆排序使用堆来选数，相比于直接选择排序效率就高了很多。
时间复杂度：O(N*logN)
空间复杂度：O(1)
稳定性：不稳定
————————————————
版权声明：本文为CSDN博主「空洞的眼 眸阁」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_43806995/article/details/97778848
